# -*- coding: utf-8 -*-
"""TareaProgra.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I8-XIN-M_vySO-SgwPXkzmvQsHxoM1L8

‚Ä¢ ¬øQu√© es un paradigma de programaci√≥n?

Es una forma de enfocar un lenguajes de programaci√≥n para estructuras programas con ciertas caracter√≠sticas propias, proporcionando t√©cnicas y metolodog√≠as para dise√±ar soluciones a problemas con un estilo especifico de pensamiento.


‚Ä¢ ¬øEn qu√© se basa la programaci√≥n orientada a objetos?

La programaci√≥n oritentada a objetos (POO) es uno de los paradigmas de programaci√≥n m√°s utilizados debido a sus caracter√≠sticas inherentes, que facilitan tanto el desarrollo de aplicaciones sencillas como complejas. Se distingue por su enfoque en la organizaci√≥n del software a trav√©s de "objetos" y "clases", lo que permite crear programas modulares y representar de manera eficiente conceptos del mundo real mediante la abstracci√≥n de datos y la agrupaci√≥n de informaci√≥n.

‚Ä¢ ¬øCu√°l es la diferencia entre recursividad e iteraci√≥n, y c√≥mo se relaciona esto con la notaci√≥n big ùëÇ?

Tanto la recursividad como la iteraci√≥n son conceptos relacionados a la existencia de un bucle, el cual se repite m√∫ltiple veces hasta cumplir con un objetivo previamente establecido.

La diferencia entre ambas radica en su estructura.La recursividad se define de tal forma que una funci√≥n se llame a si misma cuando no se cumple con los casos base, es decir, la ejecuci√≥n del cuerpo de una funci√≥n recursiva puede requerir la aplicaci√≥n de dicha funci√≥n varias veces con el fin de resolver el problema.

Por otra parte, los bucles iterativos se caracterizan por repetir el mismo procedimiento varias veces. Entre ellos, se destacan el bucle "for", que repite el procedimiento un n√∫mero determinado de veces, y el bucle "while", que repite el procedimiento hasta que se cumpla una condici√≥n espec√≠fica.

Con respecto a su relacion con la notaci√≥n big O, la elecci√≥n de como estructurar un programa para resolver un problema es crucial para la eficiencia del algoritmo. Big O es una forma de expresar la complejidad de un algoritmo en t√©rminos de eficiencia, por lo que decidir entre usar un bucle iterativo o uno recursivo influye a la notaci√≥n big O del programa.


‚Ä¢ explicar la diferencia de rendimiento entre ùëÇ(1) y ùëÇ(ùëõ)

Big O es una forma de comparar la eficiencia de distintos enfoques de un problema, el cu√°l considera distintos factores para clasificar la eficiencia del programa, como la complejidad en funci√≥nd del tama√±o de la entrada, la independencia de la m√°quina y el "working storage".

O(1) significa que el n√∫mero de operaciones que debe realizar el algoritmo para completar una tarea determinada es independiente del tama√±o de la entrada, siendo el tipo de algoritmo m√°s r√°pido. Por otra parte, un programa 0(n) es de tiempo lineal, por lo que crece directamente proporcional al tama√±o de su entrada.  

‚Ä¢ ¬øC√≥mo se calcula el orden en un programa que funciona por etapas?

Se debe ver el orden de cada etapa del programa para luego compararlos entre ellos. Los t√©rminos est√°n dominados entre ellos seg√∫n el tiempo en que tardan en resolver su funci√≥n, por lo que el orden del programa es igual al de mayor dominancia seg√∫n: O(1) < O(log(n)) < O(n) < O(nlog(n)) < O(n2) < O(2n) < O(n!)

‚Ä¢ ¬øC√≥mo se puede determinar la complejidad temporal de un algoritmo recursivo?

Para determinar la complejidad temporal de un algoritmo recursivo se debe resolver una ecuaci√≥n llamada "relaci√≥n de recurrencia", la cual expresa el tiempo de ejecuci√≥n del algoritmo en t√©rminos de si mismo. Para resolverla hay distintas t√©cnicas, como el m√©todo de √°rbol de recurrencia o el teorema maestro.
"""

import time
import matplotlib.pyplot as plt
from math import factorial

#Primera forma:
# Creamos una matriz de NxM llena de 1. La idea de este m√©todo se basa en el hecho que solo se puede avanzar hacia la derecha o hacia abajo
# Esto implica que todos los caminos posibles para llegar a una celda son en realidad la suma de los caminos posbiles para llegar a la celda de arriba m√°s los caminos para llegar a la celda de abajo

def Metodo1(n, m):
    matriz = [[1 for x in range(m)] for y in range(n)]      # Creamos una matriz NxM solo de 1
    for i in range(1, n):
        for j in range(1, m):
            matriz[i][j] = matriz[i-1][j] + matriz[i][j-1]   # Caminos para llegar a la celda actual = Caminos para llegar a la celda de la izquierda + Caminos para llegar a la celda de arriba
    return matriz[-1][-1]

# Segunda Forma:
# Ahora, tras analizar la soluci√≥n creado por medio de bucles iterativos, nos podemos dar cuenta que el problema tambi√©n puede ser resuelto de una forma matem√°tica.
# Debemos entender que para cualquier matriz NxM, para llegar a la esquina inferior derecha se deben realizar (N-1) movimientos hacia abajo y (M-1) movimientos hacia la derecha.
# Esto implica que el resultado sea equivalente a realizar una permutaci√≥n con repetici√≥n.

def Metodo2(m, n):
    numerador = factorial(n + m - 2)
    denominador = factorial(n - 1) * factorial(m - 1)
    return int(numerador / denominador)

# Configuraciones de tama√±os de grilla
n_values = [5, 10, 15, 20, 25]
m_values = [5, 10, 15, 20, 25]

# Almacenamiento de resultados
results1 = []
results2 = []

for n, m in zip(n_values, m_values):
    start_time = time.time()
    Metodo1(n, m)
    end_time = time.time()
    results1.append(end_time - start_time)

    start_time = time.time()
    Metodo2(m, n)
    end_time = time.time()
    results2.append(end_time - start_time)

# Creaci√≥n del gr√°fico
plt.figure(figsize=(10, 5))
plt.plot(n_values, results1, label='Metodo 1')
plt.plot(m_values, results2, label='Metodo 2')
plt.xlabel('Dimension de la grilla (NxM)')
plt.ylabel('Tiempo de ejecuci√≥n (segundos)')
plt.title('Comparaci√≥n del tiempo de ejecuci√≥n de los M√©todos 1 y 2')
plt.legend()
plt.grid(True)

# Guardar el gr√°fico en formato SVG
plt.savefig('tiempos_de_ejecucion.svg')

plt.show()